Add is faster than insert, because when inserting an O(N - index (?)) operation is performed to iterate over all values.
Meanwhile, adding is an O(1) operation (unless the arraylist reaches max allocated capacity and needs to extend itself).
Binary search is only applicable on arrays sorted in non-decreasing order. This also applied to a number range, since numbers obviously increase.

Fewer if statements, even those with multiple conditions, are faster (usually, probably) than multiple if statements with one condition each.
Ex:
3 if statements with one condition each: runtime = 160,000 nanoseconds
2 if statements, one with two conditions, one with one condition: runtime = 28,000 nanoseconds
This difference is very marginal, since this time is measured in nanoseconds, but the latter is nevertheless faster.

int len = str.length()//nums.length, i = len faster than i = str.length()/nums.length
REFERENCES TO VALUES ARE FASTER. This makes sense, as len refers to an int, rather than calling str.length and calculating the length every iteration.

Multiple for loops are always faster or as fast as a nested loop.
Example: for(int i = 0; i < N; i++) for(int j = 0; j < N; i++), where N is an integer, say, 3.
    j
i = 0 1 2
    _____ = 9 iterations (N^2) for a nested loop.
    0 1 2
    0 1 2
    0 1 2

i = 0 1 2 for loop 1 = 3 iterations.
i = 0 1 2 for loop 2 = loop 1 iterations + 3 = 6 iterations total.

PROOF: N = 5. Average runtime for nested loop (nanoseconds) =

Switch is faster than if (177,700 ns for if compared to 21,200 ns for switch)

EXPONENTS:
    MULTIPLY 1 BY a b TIMES (a^b)
    EX: 4^2 = 1*4*4. a = 4, b = 2. a is the number to multiply 1 by, b is the amount of times to multiply.
    EX: 2^1 = 1*2.
    EX: 1^0 = 1. 1 is not multiplied by anything, not even by 0. Therefore, a^0 is always 1.

BINARY PROPERTIES:
    Even binary numbers end with a zero bit (ex: 2 = 10, 12 = 1100, 116 = 1110100).
    Odd binary numbers end with a one bit (ex: 9 = 1001, 11 = 1011, 117 = 1110101).
    This is why (n & 1) can be used to calculate evenness of a number. (0010 & 0001 would be 0 & 1 == 0).

    Powers of 2 start with 1 and have (int)(sqrt(num)) zeroes, except for 1, as sqrt(1) = 1, and 1 in binary is 1.
    ex: 16 = 10000. 10000 has sqrt(16) = 4 zeroes.
    Num before a power of two has all ones. Very useful for XOR/bit masking!

CONVERTING TO OTHER BASES:
    To convert from base X (10, for example) to another base Y (2, for example), divide the number by Y (int division) until the number reaches 0.
    for decimals, multiply by base Y until the number reaches 0.

    To convert to base X, divide the binary representation of a number into groups of 2^N = X, where X is 16 in this case, and Y is 4, so 4 groups (101110010 -> 1|0111|0010)
    and convert each group of numbers into a separate number then combine them (1 = 1, 0111 = 7, 0010 = 6) = 0x176. In base 8, make 2^N = 8 = 3 groups (101 = 5, 110 = 6, 010 = 2) = 0562.

    

import java.util.Arrays;

public class ShiftArray {
    public static void main(String[] args){
        long time = System.nanoTime();
    }

    //shift arr count times in a direction. TESTED AND WORKING O((count % len) * len) time.
    public static int[] shiftLeftSlow(int[] arr, int count){
        int len = arr.length;
        count %= len; //avoid extra shifts and out of bounds errors

        for(int i = 0; i < count; i++){ //shift count times
            for(int j = 0; j < len - 1; j++){
                int val = arr[j];

                arr[j] = arr[j + 1];
                arr[j + 1] = val;
            }
        }
        return arr;
    }

    public static int[] shiftRightSlow(int[] arr, int count){
        int len = arr.length;
        count %= len;

        for(int i = 0; i < count; i++){
            for(int j = len - 1; j > 0; j--){
                int val = arr[j];

                arr[j] = arr[j - 1];
                arr[j - 1] = val;
            }
        }
        return arr;
    }

    // WORKING. using extra space. O(N) time, O(N) space. much faster algorithm, but Arrays.CopyOf/System.arraycopy adds extra runtime.
    public static int[] shiftLeft(int[] arr, int count){
        int len = arr.length;
        count %= len; //reduce extra shifts, since shifting once in an array of 5 values is the same as shifting 6 times.

        if(count == 0){ //not necessary to shift array if count is divisible by array length (s
            return arr;
        }

        int leftIndex = 0;//pointer to insertion point when shifting out of bounds
        int[] arrCopy = arr;
        System.arraycopy(arr, 0, arrCopy, 0, len);//create copy of array to extract values from.

        for(int i = 0; i < len; i++){
            if((i + count) < len){//if in bounds, shift count spaces over
                arr[i] = arrCopy[i + count];
            }

            else{//if out of bounds, add at next unused and leftmost insertion point.
                arr[i] = arrCopy[leftIndex];
                leftIndex++;
            }
        }
        return arr;
    }

    public static int[] shiftRight(int[] arr, int count){
        int len = arr.length;
        count %= len;

        if(count == 0){
            return arr;
        }

        int rightIndex = len - 1;
        int[] arrCopy = Arrays.copyOf(arr, len);

        for(int i = len - 1; i >= 0; i--){
            if((i - count) >= 0){
                arr[i] = arrCopy[i - count];
            }

            else{
                arr[i] = arrCopy[rightIndex];
                rightIndex--;
            }
        }
        return arr;
    }
}



public final class Operators{
    public static void main(String[]args){
        /*
            BIT COUNT:
            1 Byte = 8 bits.
            Boolean: 1 bit: 0 = false, 1 = true.
            Byte: 8 bits: Min = -128, max = 127. Utility: saves memory, lets you know that the value is small.
            Short: 16 bits: Min = -32,768, max = 32767. Same utility as bytes.
            Int: 32 bits: Min = -2^-31, max = 2^31 - 1. Can use integer class to create unsigned integers I guess.
            Long: 64 bits: Min = -2^63, max = 2^63-  1. Useful for very large values. Can use long class for unsigned values.

            Float: 32 bits: Same as int but with decimals. Single-precision.
            Double: 64 bits: Same as long but with decimals. Double-precision.

            Char: 16 bits: Are unsigned, and have a max value of 65,535 (even though there are only around 250 chars).

            Based on how many digits are in a binary number, there are 2^digits count combinations. For ex: if there are 8 digits, there are 2^8 = 256 combinations.
            The range goes from -2^X to 2^X - 1.
         */

        int bin = 0b0101; //0b + binary numbers.
        int hex = 0x5; //0x + hexadecimal numbers.
        int oct = 05; //0 + octal numbers.

        System.out.println("Binary 5: " + bin);
        System.out.println("Hex 5: " + hex);
        System.out.println("Octal 5: " + oct);

        System.out.println();
        /*
            ARITHMETIC OPERATORS:
            Simple: +, -, *, /, and %.

            UNARY OPERATORS:
            Includes operators that do not need two operands. Ex: !x or -5 (negative 5), whereas 5 + 5 requires two operands.
            ! - not, - = negative number. ~ = complement, ++x = prefix, x++ = postfix.
            Are all obviously much more efficient and readable than doing "x = x + 1" or "x == false".

            ASSIGNMENT OPERATORS:
            = and += / -= etc.

            RELATIONAL OPERATORS:
            Compares two values. Includes ==, >, <, etc, returning true and/or executing code if true.
         */

        //LOGICAL OPERATORS:
        //Includes && (logical AND), || (logical OR), ! (logical NOT), ^ (logical XOR)

        //BITWISE OPERATORS
        System.out.println("Bitwise OR: " + (5 | 7)); //if either bit is one, the result will give one for the bit (0111).
        System.out.println("Bitwise AND: " + (5 & 7)); //if both bits are one (0101).
        System.out.println("Bitwise XOR: " + (5 ^ 7)); //if only one bit is on/off (0010, or 2 in decimal).
        System.out.println("Complement / Bitwise NOT: " + ~5); //flips 0s and 1s (1010, or 10 in decimal).

        //SHIFT OPERATORS
        System.out.println("Bitwise right shift: " + (5 >> 7)); //shifts bits x (7, in this case) bits to the right.
        System.out.println("Bitwise left shift: " + (5 << 7)); //shifts bits x (7, in this case) bits to the left.
        //there are also the <<< and >>> bitwise operators for unsigned values, but who the fuck cares.

        //BIT MATH:
        byte bit = 1, op = 1;

        System.out.println("\n5 <<= 1 (5 * ( 1 * 2)):");
        System.out.println(bit);
        System.out.println(bit <<= op);
        System.out.println(bit <<= op);

        bit = 5; op = 2;

        System.out.println("\n5 <<= 2 (5 * (2 * 2)):");
        System.out.println(bit);
        System.out.println(bit <<= op);
        System.out.println(bit <<= op);

        bit = 100; op = 1;

        System.out.println("\n100 >>= 1 (100 / (1 * 2)):");
        System.out.println(bit);
        System.out.println(bit >>= op);
        System.out.println(bit >>= op);

        bit = 100; op = 2;

        System.out.println("\n100 >>= 2 (100 / (2 * 2)):");
        System.out.println(bit);
        System.out.println(bit >>= op);
        System.out.println(bit >>= op);

        /*
            OPERATOR PRECEDENCE (if on the same level, evaluate given code left to right (operators on the same level are equal in precedence)).
            1: Postfix: x++, x--
            2: Unary: prefix, !, etc.
            3: Multiplicative: *, /, %
            4: Additive: +, -.
            5: Shift: >>, <<, >>>.
            6: Relational: >, >=, <=, instanceOf(), etc.
            7: Equality: ==, !=
            8: Bitwise AND: &
            9: Bitwise XOR: ^
            10: Bitwise OR: |
            11: Logical AND: &&
            12: Logical OR: ||
            13: Ternary: ?, :
            14: Assignment: =, +=, -=, etc.
         */
    }
}



import java.util.Scanner;

public class CalculatorBasic{//FINISHED, EXCEPT FOR OPERATOR PRECEDENCE (PEMDAS).
    public static void main(String[]args){
        Scanner scan = new Scanner(System.in);

        /* Test cases; method integrities verified.
        System.out.println(toInt(new StringBuilder("5000")));
        System.out.println(toInt(new StringBuilder("0")));
        System.out.println(toInt(new StringBuilder("17")));

        ERROR TESTS
        System.out.println(getResult("1+s+2")); //letter present, throws an error
        System.out.println(getResult("11")); //too short and no operators, throws an error
        System.out.println(getResult("+1+1")); //operator as 1st char, throws an error
        */

        System.out.println("This calculator does not follow PEMDAS, so expressions are read left to right.");
        System.out.println("Valid operators: +, -, *, /");

        System.out.print("Enter an expression: ");
        System.out.print(getResult(scan.nextLine()));
    }

    public static int getResult(String expression){
        expression = expression.replaceAll(" ","");
        handleErrors(expression);
        System.out.println(expression);

        int len = expression.length(); //reduces the calls to .length()
        int result = 0; //final value to be returned to any invokers of the getResult method
        char operator;
        StringBuilder leftNum = new StringBuilder();
        StringBuilder rightNum = new StringBuilder();

        for(int i = 0; i < len; i++){
            char currChr = expression.charAt(i);

            if(isOperator(currChr)){ //if char is an operator. then append numbers until another operator is reached.
                operator = currChr;
                i++; //get to next character

                while(i < len && isNum(expression.charAt(i))){
                    rightNum.append(expression.charAt(i));
                    i++;
                }

                result = toInt(leftNum);
                int rightInt = toInt(rightNum);

                switch(operator) {
                    case '+':
                        result += rightInt;break;
                    case '-':
                        result -= rightInt;break;
                    case '*':
                        result *= rightInt;break;
                    case '/':
                        result /= rightInt;break;
                }

                leftNum = new StringBuilder("" + result);
                rightNum = new StringBuilder(); //working left to right, so leftNum becomes rightNum. now, leftNum will do operations on the rightNum.
                i--;
            }

            else{ //if the first set of numbers all the way on the left of the expression
                while(isNum(expression.charAt(i))){
                    leftNum.append(expression.charAt(i));
                    i++;
                }
                i--; //prevent adding to i twice, since I will be increased in the while loop then increased in the for loop, thus skipping a character.
            }
        }
        return result;
    }
    //HELPER METHODS
    private static void handleErrors(String expression) throws NumberFormatException{
        int len = expression.length();

        if(!isNum(expression.charAt(0)) || !isNum(expression.charAt(len - 1))){
            throw new NumberFormatException("Invalid expression; non-numerical and non-operator characters are not allowed..");
        }//if expression has invalid 1st or last char.

        if(len < 3){
            throw new NumberFormatException("Invalid expression; not a valid expression.");
        }//if less than 3 chars, therefore invalid (min valid is 1+1 etc.)

        int operatorCount = 0;
        for(int i = 1; i < len - 1; i++){
            char currChr = expression.charAt(i);

            if(isOperator(currChr)){
                operatorCount++;
            }

            if(!isOperator(currChr) && !isNum(currChr) ||(isOperator(expression.charAt(i - 1))
                    && isOperator(currChr)) || (isOperator(expression.charAt(i + 1)) && isOperator(currChr))){
                throw new NumberFormatException("Invalid expression; non-numerical characters are not allowed, or expression is invalid.");
            }//if not an operator or num at i, or if there are two operators in a row.
        }

        if(operatorCount == 0){
            throw new NumberFormatException("Invalid expression; no operators are present.");
        }//if no operators are present (ex: 111 is not a valid expression).
    }

    private static boolean isOperator(char chr){
        return switch (chr){
            case '+', '-', '*', '/' -> true;
            default -> false;
        };
    }

    private static boolean isNum(char chr){
        return chr >= '0' && chr <= '9';
    }

    private static int toInt(StringBuilder num){
        int result = 0;

        for(int i = 0; i < num.length(); i++){
            result += (num.charAt(i) - 48) * (int)(Math.pow(10, num.length() - i - 1));
        }//convert char at index i to an int, then multiply it by (10 * str length - 1), and decrease i to account for the next digit.

        return result;
    }
}